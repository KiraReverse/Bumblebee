hi youtube! 

i've done it. 

python bot playing maplestory minigame - infinity race. 

let me show you the result. 

what do you think?

0 bumb into the rock. 

very cool isn't it. 

let's try one more time. 

(racing with 2 hackers just now XD)

this game just doesn't ban bots and hackers dxdxxxxxxxdxd

nah they still ban, you just have to becareful. 

woo hooo!! we won against a real player!!!!!!!

for the rest of the video, i will show you how i do it. 

but, instead of showing you the code, i want to walk you through my thought process. 

let's start from the beginning. 

first, i want to know, how fast, or at what rate does a python while loop loop?

let's comment out all the other codes, and just run a plain while loop. 

ok that pretty much it. let's run. 

ooh we need to print out some numbers ..

okk that is really fast. 

on average, it is .000001 seconds, which is 1 microsecond, or 1000 nano second. 

next, i have the rgb color of the rock, specifically, this pixel right here, (204,187,187)

now, i want to know, what is the rate, or how fast does my pixel detection detect the color from the image. 

let's find out. 

so i have this function here, rock_checker. 

i actually created 3 variant of the function, with different x value, you will know why later. 

but first let's just run the first one. 

ok that pretty much it. 

ok on average, each loop takes 0.002 seconds ~ 0.004 seconds. sometimes 0.013 0.007

ok this is actually very good, that means in every second, my pixel detection code detect the color on the screen 1/0.004=250 times!

impressive. 

now that is because i am using the gdi_capture library taken from  
https://github.com/qlvbrknp/maple-bot

thank you qlvbrknp. 

it says that it is faster than pyautogui and d3dshot. 

is it true?

ok, i am lazy to learn pyautogui/d3dshot. 

i ask chatgpt to write it for me. 

but chatgpt uses Pillow. 

let's see the speed of Pillow ImageGrab. 

oh, let's do both comparison at the same time!

this is for Pillow. 

and this is for gdi_capture. 

because we are using numpy to find the rgb color, 

so let's see how fast does it take for numpy to run that too. 

then we print now1, now3, and now5. 

ok let's run. 

sorry, small error. let's run again. 

n1 (Pillow) took 0.0306 seconds. 
n3 (gdi_capture) took 0.005 seconds. 
numpy took 0.0000708 seconds. 

so yes, gdi_capture is faster than Pillow. 

but. does the conversion affect its speed?

just ImageGrab. 

trivial!

ImageGrab simply take too much time to run its screenshot function. 

okay!

let's move on. 

now, notice i wrote three different detection x value here. 
430, 460, 500. 

because the minigame consist of 3 stage, of 3 different speed. 

about this point. have to minus (1,31) due to windows border and title. 
no actually, is +1. 

here. 

then, i extend it to length of 30 pixel wide. 
to 460. 

about there. 

so this is the region for the first stage, to detect our rock pixel. 

if we move to the right, there's no rock there. wait. 

ok we forgot to +31 to our y value. ops. 

292+31=323. i actually did this calculation the other day. 

ok now if we move to the right, 

about there, maybe i calculated wrongly by 1 pixel but, 

anyways, 

moving on. 

on second stage, it is 460~490. 
on the third stage (the fastest speed), we need to look slightly further, 
before we press down our jump/duck key. 

so i set it to 500~530. 

yeah 

so basically, 

we will detect that region, and return True, if rock pixel is found. 
we do the same for the third row's rock. here:

so in our code, we are detecting 2 places. 

oh, i also minus 15 pixel (to the left) for the 2nd row. 

it makes sense now. 

because we need to duck slightly later. 
basically the moment see see a rock, we duck. 

but for jump case, we need to jump slightly earlier. 

okay. 

so here, return a tuple (True,False) if 2nd row rock pixel found. 
return (False,True) if 3rd row rock pixel found. 

THEN, 

we create a parallel thread (not really parallel. sorry comp sci student. )
we create a thread to do this pixel detection for us. 
then, we simply set the flag to True. 
2 flags here. 1 for 2nd row. 1 for 3rd row. 

THEN,

in our main loop (which runs insanely fast (1 microsecond)), 
we simply check our flag in each loop. 
which is 1 million checks per second?????????????????? yeah?????????

once our flag=True, we immediately set it to False, 
then we will press down/jump. 

now here is the amazing part. 

we press down, until  either flag is True again. 

idk how to explain how amazing this part of the code is but,

okay, the last thing. 

how do we determine which stage we are currently in?

we use timer. 

each stage last for 15 seconds. 

so after each loop, we do this. 

fourth stage is the bonus coin stage. 

then we just set accordingly, fourth=True, third=True,second=True, ... 

then depending on which stage we're in, we

oh, not here.  

ok this code here is redundant. i can simplify it later. 

the important part is the detector part. 

here. 

so we will run accordingly, rock_checker, rock_chhecker2, rock_checker3. 

ok, one last time. 

alright, thanks for watching. 

hope you learn something in this video. 

code in the description. https://github.com/agumonlyt/Bumblebee

i will create a backup for this main file. in case you're watching this in the future. 

see ya!








































